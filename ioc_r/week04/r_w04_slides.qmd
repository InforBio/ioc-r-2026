---
title: "Building Logic:<br>Operators, Conditions, and Functions"
subtitle: "IOC-R Week 4"
date: "2025-11-24"
date-format: " "
format:
  revealjs: default
echo: true
categories: 
  - week04
  - slides
image: images/preview_w4.png
---

# Recap Week 3

## Brief Recap Week 3 {.smaller}

::: {.columns}
::: {.column}
- Data frames: row-column structure

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
df
```

- Lists: store anything

```{r}
my_list <- list(x = 1:3, y = letters[5:1])
my_list
```
:::

::: {.column .fragment}

::: {.callout-tip appearance="simple"}
What are the outputs for following codes?
:::

```{r}
#| eval: false

df$x
df[[2]]
df[3, ]
df[, "y", drop = FALSE]
df[1, 2]
```

::: {.fragment}
<br>

```{r}
#| eval: false

my_list$x
my_list[1]
my_list["y"]
my_list[[2]][3]
```

:::

:::
:::


:::{.notes}
list is often used to store meta data

Motivation for Week 4
- Why learn operators, conditions, and functions?
- Real-world examples (e.g., filtering data, automating repetitive tasks, decision-making in analysis).
:::

# Operators

## Assignment and Arithmetic Operators {.smaller}

::: {.columns}
::: {.column}
- Assignment operators: `<-`, `=`

```{r}
x <- 1
x

y = "abc" # not recommanded
y

# assign value to functionâ€™s parameter
mean(x = 1:3)
```
:::

::: {.column .fragment}
- Arithmetic operators: `+`, `-`, `*`, `/`, `^` (exponentiation), *etc*.

```{r}
10^3
```

::: {.fragment}

```{r}
x <- c(2, 8, 3)
x - 1
x - 1:3
```
:::

::: {.fragment}
```{r}
y <- c(6, 4, 1)
x + y
x * y
x / y
```
:::
:::
:::


## Comparison Operators {.smaller}

Element-wise comparison: `>`, `<`, `>=`, `<=`, `==`, `!=`,
returns logical results.

::: {.columns}
::: {.column}

```{r}
10 > 3
10 >= 3
10 < 3
10 <= 3
10 == 3 # equal
10 != 3 # not equal
```
:::

::: {.column .fragment}
```{r}
x <- c(2, 8, 3)
y <- c(6, 8, 1)
x == y
x != y
x > y
x <= y
```

::: {.callout-tip appearance="simple" .fragment}
What are the expected results?

- `x == 8`
- `y > 1`
- `a` is a vector of numbers 1 to 5, `a[a > 3]` returns?
:::
:::
:::

## Logical Operators {.smaller}

Element-wise comparison: NOT (`!`), AND (`&`), OR (`|`), *etc.*,
returns logical values.

::: {.columns}
::: {.column}

```{r}
!TRUE
!FALSE
```

::: {.fragment}
To combine two conditions A and B:

| A     | B     | A & B | A \| B |
|-------|-------|-------|--------|
| TRUE  | TRUE  | **TRUE**  | TRUE   |
| TRUE  | FALSE | FALSE | TRUE   |
| FALSE | TRUE  | FALSE | TRUE   |
| FALSE | FALSE | FALSE | **FALSE**  |
:::

:::
::: {.column .fragment}

::: { .callout-tip appearance="simple"}
What are the expected results?

- `(3 > 1) & (7 < 5)`
- `(3 > 1) | (7 < 5)`
:::

::: {.fragment}
```{r}
(3 > 1) & (7 < 5)
(3 > 1) | (7 < 5)
```

:::
:::
:::

## The `%in%` Operator {.smaller}

We use `%in%` to check if left-side values are present in right-side,
it returns logical values.

::: {.columns}
::: {.column}
```{r}
## check membership
1 %in% 1:3
1:3 %in% 1
"a" %in% c("abc", "a")
```

:::
::: {.column}
::: {.fragment .callout-tip appearance="simple"}
Data frame `df` has two columns named `x` and `y`,
what is the result of following code?

`"col3" %in% colnames(df)`
:::

::: {.fragment}
```{r}
"col3" %in% colnames(df)
```

:::
:::
:::


## Bonus: Operator Precedence {.smaller}

::: {.columns}
::: {.column}
Simplified precedence order[^1] (highest to lowest):

1. Arithmetic (`^` > `*`, `/` > `+`, `-`)
2. Relational (`>`, `<`, `>=`, `<=`, `==`, `!=`)
3. Membership (`%in%`)
4. Logical (`!` > `&` > `|`)
:::
::: {.column .fragment}

Order can be change using `()`:

```{r}
1 + 2 * 3
(1 + 2) * 3
```

::: {.fragment}
```{r}
TRUE | TRUE & FALSE
```
:::
::: {.fragment}
```{r}
(TRUE | TRUE) & FALSE
```
:::

:::
:::

[^1]: For more detail, check the [operator documentation](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html).


## `any()`, `all()` and `which()` {.smaller}

::: {.columns}
::: {.column}
Given a set of logical vectors: 
```{r}
-3:3
-3:3 > 0
```

- `any()`: is at least one of the values `TRUE`?

```{r}
any(-3:3 > 0)
```

- `all()`: are all of the values `TRUE`?

```{r}
all(-3:3 > 0)
```

- `which()`: return indices of `TRUE` values.

```{r}
which(-3:3 > 0)
```
:::
::: {.column .fragment}
::: {.callout-tip appearance="simple"}
We have a vector `log2FoldChange <- c(1.2, -0.5, 0.9, 0.7, -1.1)`, what are the expected results for the following codes?

- `which(log2FoldChange > 0.8)`
- `any(log2FoldChange > 0.8)`
- `all(log2FoldChange > 0)`

:::
:::
:::

# Conditions

## Conditional Statements {.smaller}

Conditional statements allow us to make decisions based on logical conditions,
guiding how the code behaves in different scenarios.

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  AA[Age] --> A((&gt; 18))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[print &quot;Adult&quot;]
  C --> E[print &quot;Minor&quot;]
```

. . . 

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  AA[P-value] --> A((&lt; 0.05))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[print &quot;Significant&quot;]
  C --> E[print &quot;Non significant&quot;]
```


## `if` and `if else` {.smaller}

::: {.columns}
::: {.column}

Syntax:
```{r}
#| eval: false

## if statement
if (condition) {
  # code to run if `condition` is TRUE
}

## if else statement
if (condition) {
  # code to run if `condition` is TRUE
} else {
  # code to run if `condition` is FALSE
}
```

::: {.callout-important appearance="simple"}
- You can use `if` without `else` but never in the opposite way.
- The condition must evaluate to exactly **one logical value** (`TRUE` or `FALSE`) and cannot be NA.
:::
:::
::: {.column .fragment}

```{mermaid}
%%| echo: false
flowchart LR
  AA[P-value] --> A((&lt; 0.05))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[print &quot;Significant&quot;]
  C --> E[print &quot;Non significant&quot;]
```


```{r}
pvalue <- 0.1
if (pvalue < 0.05) {
  # code to run if condition is TRUE
  print("Significant")
} else {
  # code to run if condition is FALSE
  print("Non significant")
}
```

::: {.fragment .callout-tip appearance="simple"}
What will you get when `pvalue` is 0.03?
:::

::: {.fragment}
```{r}
#| echo: false

pvalue <- 0.03
if (pvalue < 0.05) {
  print("Significant")
} else {
  print("Non significant")
}
```
:::
:::
:::


## The `ifelse()` Function  {.smaller}

Syntax:
```{r}
#| eval: false
ifelse(test, yes, no)
```

Example:

```{r}
pvalue <- 0.01
ifelse(test = pvalue < 0.05, yes = "Significant", no = "Non significant")
```

. . .

The "test" parameter can be a logical vector.

```{r}
vec_p <- c(0.02, 0.049, 0.1)
ifelse(vec_p < 0.05, yes = "Significant", no = "Non significant")
```


# Functions 

## What is a Function? {.smaller}

Functions = Reusable blocks of code.

. . .

![](images/call_function.png)

::: {.notes}
Functions that are part of R's base installation, always available without needing to load any additional packages.
To use a function, write the **function's name** followed by `()`,
place any required input (arguments/parameters) inside the `()`.
:::

::: {.fragment .callout-note appearance="simple"}
Use `?` or `help()` to view the function's documentation, *e.g.*: `?mean`, `help(mean)`
:::


## Using Functions {.smaller}

Functions = Reusable blocks of code.

- Built-in functions
```{r}
#| eval: false
mean(x = 1:3)
```

- Functions from additional packages
```{r}
#| eval: false

# install.packages("readr")         # one time only if not yet installed
library(readr)                      # load the package (every new R session)
read_csv(file = "path/to/data.csv")
```

::: {.callout-note appearance="simple"}
We'll talk about packages next week!
:::

. . .

- Custom functions

::: {.callout-note appearance="simple"}
We'll talk about customised functions in session 8!
:::


# Let's Practice !

## Today's Goals

- Understand and use operators to filter data with precision.
- Apply functions to perform basic calculations and data manipulation.
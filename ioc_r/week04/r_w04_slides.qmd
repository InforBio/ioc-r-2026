---
title: "Building Logic:<br>Operators, Conditions, and Functions"
subtitle: "IOC-R Week 4"
date: "2025-11-24"
date-format: " "
format:
  revealjs: 
    toc: true
    toc-title: "Plan"
    toc-depth: 1
    slide-number: true
    preview-links: auto
    logo: ../../images/logoInforBio_fond_blanc_small.png
    css: ../custom.css
  # pdf:
  #   toc: true
echo: true
categories: 
  - week04
  - slides
image: images/preview_w4.png
---

# Recap Week 3

## Brief Recap Week 3 {.smaller}

::: {.columns}
::: {.column}
- Data frames: row-column structure

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
df
```

- Lists: store anything

```{r}
my_list <- list(x = 1:3, y = letters[5:1])
my_list
```
:::

::: {.column .fragment}

::: {.callout-tip appearance="simple"}
What are the outputs for following codes?
:::

```{r}
#| eval: false

df$x
df[[2]]
df[3, ]
df[, "y", drop = FALSE]
df[1, 2]
```

::: {.fragment}
<br>

```{r}
#| eval: false

my_list$x
my_list[1]
my_list["y"]
my_list[[2]][3]
```

:::

:::
:::


:::{.notes}
list is often used to store meta data

Motivation for Week 4
- Why learn operators, conditions, and functions?
- Real-world examples (e.g., filtering data, automating repetitive tasks, decision-making in analysis).
:::

# Operators

## Assignment and Arithmetic Operators {.smaller}

::: {.columns}
::: {.column}
- Assignment operators: `<-`, `=`

```{r}
x <- 1
x

y = "abc" # not recommanded
y

# assign value to functionâ€™s parameter
mean(x = 1:3)
```
:::

::: {.column .fragment}
- Arithmetic operators: `+`, `-`, `*`, `/`, `^` (exponentiation), *etc*.

```{r}
10^3
```

::: {.fragment}

```{r}
x <- c(2, 8, 3)
x - 1
x - 1:3
```
:::

::: {.fragment}
```{r}
y <- c(6, 4, 1)
x + y
x * y
x / y
```
:::
:::
:::


## Comparison Operators {.smaller}

Element-wise comparison: `>`, `<`, `>=`, `<=`, `==`, `!=`,
returns logical results.

::: {.columns}
::: {.column}

```{r}
10 > 3
10 >= 3
10 < 3
10 <= 3
10 == 3 # equal
10 != 3 # not equal
```
:::

::: {.column .fragment}
```{r}
x <- c(2, 8, 3)
y <- c(6, 8, 1)
x == y
x != y
x > y
x <= y
```

::: {.callout-tip appearance="simple" .fragment}
What are the expected results?

- `x == 8`
- `y > 1`
- `a` is a vector of numbers 1 to 5, `a[a > 3]` returns?
:::
:::
:::

## Logical Operators {.smaller}

Element-wise comparison: NOT (`!`), AND (`&`), OR (`|`), *etc.*,
returns logical values.

::: {.columns}
::: {.column}

```{r}
!TRUE
!FALSE
```

::: {.fragment}
To combine two conditions A and B:

| A     | B     | A & B | A \| B |
|-------|-------|-------|--------|
| TRUE  | TRUE  | **TRUE**  | TRUE   |
| TRUE  | FALSE | FALSE | TRUE   |
| FALSE | TRUE  | FALSE | TRUE   |
| FALSE | FALSE | FALSE | **FALSE**  |
:::

:::
::: {.column .fragment}

::: { .callout-tip appearance="simple"}
What are the expected results?

- `(3 > 1) & (7 < 5)`
- `(3 > 1) | (7 < 5)`
:::

::: {.fragment}
```{r}
(3 > 1) & (7 < 5)
(3 > 1) | (7 < 5)
```

:::
:::
:::

## The `%in%` Operator {.smaller}

We use `%in%` to check if left-side values are present in right-side,
it returns logical values.

::: {.columns}
::: {.column}
```{r}
## check membership
1 %in% 1:3
1:3 %in% 1
"a" %in% c("abc", "a")
```

:::
::: {.column}
::: {.fragment .callout-tip appearance="simple"}
Data frame `df` has two columns named `x` and `y`,
what is the result of following code?

`"col3" %in% colnames(df)`
:::

::: {.fragment}
```{r}
"col3" %in% colnames(df)
```

:::
:::
:::


## Bonus: Operator Precedence {.smaller}

::: {.columns}
::: {.column}
Simplified precedence order[^1] (highest to lowest):

1. Arithmetic (`^` > `*`, `/` > `+`, `-`)
2. Relational (`>`, `<`, `>=`, `<=`, `==`, `!=`)
3. Membership (`%in%`)
4. Logical (`!` > `&` > `|`)
:::
::: {.column .fragment}

Order can be change using `()`:

```{r}
1 + 2 * 3
(1 + 2) * 3
```

::: {.fragment}
```{r}
TRUE | TRUE & FALSE
```
:::
::: {.fragment}
```{r}
(TRUE | TRUE) & FALSE
```
:::

:::
:::

[^1]: For more detail, check the [operator documentation](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html).


## `any()`, `all()` and `which()` {.smaller}

::: {.columns}
::: {.column}
Given a set of logical vectors: 
```{r}
-3:3
-3:3 > 0
```

- `any()`: is at least one of the values `TRUE`?

```{r}
any(-3:3 > 0)
```

- `all()`: are all of the values `TRUE`?

```{r}
all(-3:3 > 0)
```

- `which()`: return indices of `TRUE` values.

```{r}
which(-3:3 > 0)
```
:::
::: {.column .fragment}
::: {.callout-tip appearance="simple"}
We have a vector `log2FoldChange <- c(1.2, -0.5, 0.9, 0.7, -1.1)`, what are the expected results for the following codes?

- `which(log2FoldChange > 0.8)`
- `any(log2FoldChange > 0.8)`
- `all(log2FoldChange > 0)`

:::
:::
:::

# Conditions

## Conditional Statements {.smaller}

Conditional statements allow us to make decisions based on logical conditions,
guiding how the code behaves in different scenarios.

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  AA[temperature] --> A((&gt; 37))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[Fever]
  C --> E[Normal]
```

. . . 

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  AA[log2FC] --> A((&gt; 0))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[Up-regulated]
  C --> E[Not up-regulated]
```


## `if` and `if else` {.smaller}

::: {.columns}
::: {.column}

Syntax:
```{r}
#| eval: false

## if statement
if (condition) {
  # code to run if `condition` is TRUE
}

## if else statement
if (condition) {
  # code to run if `condition` is TRUE
} else {
  # code to run if `condition` is FALSE
}
```

::: {.callout-important appearance="simple"}
- You can use `if` without `else` but never in the opposite way.
- The condition must evaluate to exactly **one logical value** (`TRUE` or `FALSE`) and cannot be NA.
:::
:::
::: {.column .fragment}

```{mermaid}
%%| echo: false
flowchart LR
  AA[log2FC] --> A((&gt; 0))
  A --> B(TRUE)
  A --> C(FALSE)
  B --> D[Up-regulated]
  C --> E[Not up-regulated]
```


```{r}
log2FC <- 2.5
if (log2FC > 0) {
  # code to run if condition is TRUE
  print("Up-regulated")
} else {
  # code to run if condition is FALSE
  print("Not up-regulated")
}
```

::: {.fragment .callout-tip appearance="simple"}
What will you get when `log2FC` is 0?
:::

::: {.fragment}
```{r}
#| echo: false

log2FC <- 0
if (log2FC > 0) {
  print("Up-regulated")
} else {
  print("Not up-regulated")
}
```
:::
:::
:::


## The `ifelse()` Function  {.smaller}

Syntax:
```{r}
#| eval: false
ifelse(test, yes, no)
```

Example:

```{r}
log2FC <- -1
ifelse(test = log2FC > 0, yes = "Up-regulated", no = "Not up-regulated")
```

. . . 

```{r}
# nested condition
ifelse(
  test = log2FC > 0,
  yes = "Up-regulated",
  no = ifelse(log2FC < 0, yes = "Down-regulated", no = "No change")
)
```

. . .

The "test" parameter can be a logical vector.

```{r}
vec_lfc <- c(-1, 0, 1)
ifelse(vec_lfc > 0, yes = "Up-regulated", no = "Not up-regulated")
```


# Functions 

## What is a Function? {.smaller}

Functions = Reusable blocks of code.

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  A[Inputs] --> B(Code block for specific task)
  B --> C[Output]
```

. . .

To use a function, write the **function's name** followed by `()`,
place any required input (arguments/parameters) inside the `()`.

- Built-in functions

```{r}
mean(x = 1:3)
```

::: {.notes}
Functions that are part of R's base installation, always available without needing to load any additional packages.
:::

::: {.fragment .callout-note appearance="simple"}
Use `?` or `help()` to view the function's documentation, *e.g.*: `?mean`, `help(mean)`
:::


## Using Functions {.smaller}

Functions = Reusable blocks of code.

- Built-in functions
- Functions from additional packages
```{r}
#| eval: false

# install.packages("readr")         # one time only if not yet installed
library(readr)                      # load the package (every new R session)
read_csv(file = "path/to/data.csv")
```

::: {.callout-note appearance="simple"}
We'll talk about packages next week!
:::

. . .

- Custom functions

```{r}
add_one <- function(x) {x + 1}
add_one(x = 1:3)
```

::: {.callout-note appearance="simple"}
We'll talk about customised functions in session 8!
:::


# Let's Practice !

## Today's Goals

- Understand and use operators to filter data with precision.
- Apply functions to perform basic calculations and data manipulation.